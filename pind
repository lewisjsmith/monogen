library(dplyr)

# Generates the sequence of non-unique indices for all permutations of matrix column products
# To the desired polynomial power, p
pind<-function(x, p){

  if(p == 0 || p == 1){
    return(NULL)
  }
  
  # Column count
  n = dim(x)[2]

  # For each polynomial set
  tcol <- n^p
  
  # Indices are saved here
  indices <- matrix(0, nrow = 1, ncol = tcol)
  
  # To save indices
  it <- 1
  
  # list of 1, 4, 5, which is found from g - 1 subgroups starting index
  # These are the starting points of the known repeating pattern
  st_ind <- matrix(0, nrow=1, ncol=n)
  st_ind_c <- 1
  gc <- 0
  for(g in c(2:n)){
    for(h in c(1:(g-1))){
      st_ind[st_ind_c] <- h + gc
      st_ind_c <- st_ind_c + 1
    }
    gc <- gc + n
  }
  
  # Part 1
  # Original group size, g
  # Stacking group size, G
  # polynomial power, p
  # Following the first input, groups are of increasing size:
  # They are groups of a size of the original group squared, G
  # The amount of these groups then increases by the product of the original group...
  # for each successive polynomial power
  # e.g. the positions within these G groups are constant, 
  # for g = 3, positions 4, 7, 8 within G = 9 are non-unique, polynomial power = 2
  for(si in c(1:((n^p)/(n^2)))){
    for(sta in st_ind){
      indices[it] <- (n^p)/(n^(p-1)) + (sta + ((n^2) * (si-1)))
      it <- it + 1
    }
  }

  # Part 2
  # The positions within G become groups of size g each upon the next polynomial power
  # e.g. a previous highlighted y*x, yx, would become a xy group (xy*x, xy*y, xy*z)
  # there currently exists overlap within these two "Parts"
  for(sj in c(0:(n-1))){
    for(sta in pind(x, p-1)){
      if(sta > 0){
        indices[it] <- (((sta - 1))*n) + 1 + sj
        it <- it + 1
      }
    }
  }
  
  # Order
  indices <- sort(indices)
  
  indices <- indices[!duplicated(indices)]
  
  if(length(which(indices==0))==0){
    return(indices)
  }
  else{
    return(indices[-1])
  }
}
